// # -*- mode: c -*-
#pragma once

#include "defs.h"
#include "weight_defs_DOUBLE.h"

#ifdef __AVX512F__
#include "avx512_calls.h"
#endif

#ifdef __AVX__
#include "avx_calls.h"
#endif

#ifdef __SSE4_2__
#include "sse_calls.h"
#endif

#include <stdint.h>

typedef union {
#ifdef __AVX512F__
  AVX512_FLOATS a512;/* add the bit width for vector register*/
#endif
#ifdef __AVX__
  union {
    AVX_FLOATS a;
    AVX_FLOATS a256;
  };
#endif
#ifdef __SSE4_2__
    union {
      SSE_FLOATS s;
      SSE_FLOATS s128;
    };
#endif
    DOUBLE d;
} weight_union_DOUBLE;

// Info about a particle pair that we will pass to the weight function
typedef struct
{
    weight_union_DOUBLE weights0[MAX_NUM_WEIGHTS];
    weight_union_DOUBLE weights1[MAX_NUM_WEIGHTS];
    weight_union_DOUBLE dx, dy, dz;
    
    // These will only be present for mock catalogs
    weight_union_DOUBLE parx, pary, parz;
    
    int64_t num_weights;
} pair_struct_DOUBLE;

typedef DOUBLE (*weight_func_t_DOUBLE)(const pair_struct_DOUBLE*);
#ifdef __AVX512F__
typedef AVX512_FLOATS (*avx512_weight_func_t_DOUBLE)(const pair_struct_DOUBLE*);
#endif
#ifdef __AVX__
typedef AVX_FLOATS (*avx_weight_func_t_DOUBLE)(const pair_struct_DOUBLE*);
#endif
#ifdef __SSE4_2__
typedef SSE_FLOATS (*sse_weight_func_t_DOUBLE)(const pair_struct_DOUBLE*);
#endif

//////////////////////////////////
// Weighting functions
//////////////////////////////////

/*
 * The pair weight is the product of the particle weights
 */
static inline DOUBLE pair_product_DOUBLE(const pair_struct_DOUBLE *pair){
    return pair->weights0[0].d*pair->weights1[0].d;
}

#ifdef __AVX512F__
static inline AVX512_FLOATS avx512_pair_product_DOUBLE(const pair_struct_DOUBLE *pair){
    return AVX512_MULTIPLY_FLOATS(pair->weights0[0].a512, pair->weights1[0].a512);
}
#endif

#ifdef __AVX__
static inline AVX_FLOATS avx_pair_product_DOUBLE(const pair_struct_DOUBLE *pair){
    return AVX_MULTIPLY_FLOATS(pair->weights0[0].a, pair->weights1[0].a);
}
#endif

#ifdef __SSE4_2__
static inline SSE_FLOATS sse_pair_product_DOUBLE(const pair_struct_DOUBLE *pair){
    return SSE_MULTIPLY_FLOATS(pair->weights0[0].s, pair->weights1[0].s);
}
#endif

/*
 * Weight the pair by the signed difference in radial velocity, ( v dot rhat )
 */
static inline DOUBLE pairwise_vel_DOUBLE(const pair_struct_DOUBLE *pair){
    DOUBLE deltavx = pair->weights1[0].d - pair->weights0[0].d;
    DOUBLE deltavy = pair->weights1[1].d - pair->weights0[1].d;
    DOUBLE deltavz = pair->weights1[2].d - pair->weights0[2].d;
    
    DOUBLE invrmag = ((DOUBLE) 1.)/SQRT((pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d));
    
    return (deltavx*pair->dx.d + deltavy*pair->dy.d + deltavz*pair->dz.d)*invrmag;
}

/*
 * * Weight the pair by the squared difference in radial velocity, ( v dot rhat )^2
 */
static inline DOUBLE pairwise_vel2_DOUBLE(const pair_struct_DOUBLE *pair){
    DOUBLE deltavx = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltavy = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltavz = pair->weights0[2].d - pair->weights1[2].d;
    
    DOUBLE v_dot_r = deltavx*pair->dx.d + deltavy*pair->dy.d + deltavz*pair->dz.d;
    DOUBLE invr2 = ((DOUBLE) 1.)/((pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d));
    
    return v_dot_r*v_dot_r*invr2;
}

/*
 * * Weight the pair by the cubed difference in radial velocity, ( v dot rhat )^3
 */
static inline DOUBLE pairwise_vel3_DOUBLE(const pair_struct_DOUBLE *pair){
    DOUBLE deltavx = pair->weights1[0].d - pair->weights0[0].d;
    DOUBLE deltavy = pair->weights1[1].d - pair->weights0[1].d;
    DOUBLE deltavz = pair->weights1[2].d - pair->weights0[2].d;
    
    DOUBLE v_dot_r = deltavx*pair->dx.d + deltavy*pair->dy.d + deltavz*pair->dz.d;
    DOUBLE invr = ((DOUBLE) 1.)/SQRT((pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d));
    DOUBLE v_dot_rhat = v_dot_r*invr;
    return v_dot_rhat*v_dot_rhat*v_dot_rhat;
}

/*
 * * Weight the pair by the 4th power of the difference in radial velocity, ( v dot rhat )^4
 */
static inline DOUBLE pairwise_vel4_DOUBLE(const pair_struct_DOUBLE *pair){
    DOUBLE deltavx = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltavy = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltavz = pair->weights0[2].d - pair->weights1[2].d;
    
    DOUBLE v_dot_r = deltavx*pair->dx.d + deltavy*pair->dy.d + deltavz*pair->dz.d;
    DOUBLE invr2 = ((DOUBLE) 1.)/((pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d));
    DOUBLE v_dot_rhat_2 = v_dot_r*v_dot_r*invr2;
    
    return v_dot_rhat_2*v_dot_rhat_2;
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline DOUBLE pairwise_tang_vel2_DOUBLE(const pair_struct_DOUBLE *pair){
    DOUBLE deltavx = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltavy = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltavz = pair->weights0[2].d - pair->weights1[2].d;
    
    DOUBLE v_dot_r = deltavx*pair->dx.d + deltavy*pair->dy.d + deltavz*pair->dz.d;
    DOUBLE invr2 = ((DOUBLE) 1.)/((pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d));
    
    DOUBLE deltavx_T = deltavx - v_dot_r*pair->dx.d*invr2;
    DOUBLE deltavy_T = deltavy - v_dot_r*pair->dy.d*invr2;
    DOUBLE deltavz_T = deltavz - v_dot_r*pair->dz.d*invr2;
    
    return deltavx_T*deltavx_T + deltavy_T*deltavy_T + deltavz_T*deltavz_T;
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline DOUBLE pairwise_vel_los_DOUBLE(const pair_struct_DOUBLE *pair){

    DOUBLE d2 = (pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d);
    DOUBLE invdmag = ((DOUBLE) 1.)/SQRT(d2);
    DOUBLE invd0mag = ((DOUBLE) 1.)/SQRT((pair->weights0[0].d)*(pair->weights0[0].d) + (pair->weights0[1].d)*(pair->weights0[1].d) + (pair->weights0[2].d)*(pair->weights0[2].d));
    DOUBLE invd1mag = ((DOUBLE) 1.)/SQRT((pair->weights1[0].d)*(pair->weights1[0].d) + (pair->weights1[1].d)*(pair->weights1[1].d) + (pair->weights1[2].d)*(pair->weights1[2].d));

    DOUBLE zero = (DOUBLE) 0.;
    if (d2 < (DOUBLE) 1.e-10) {
      invdmag = zero;
    }
    
    DOUBLE deltax = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltay = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltaz = pair->weights0[2].d - pair->weights1[2].d;
    DOUBLE deltav = pair->weights0[3].d - pair->weights1[3].d;
    
    DOUBLE xhat0 = (pair->weights0[0].d) * invd0mag;
    DOUBLE yhat0 = (pair->weights0[1].d) * invd0mag;
    DOUBLE zhat0 = (pair->weights0[2].d) * invd0mag;

    DOUBLE xhat1 = (pair->weights1[0].d) * invd1mag;
    DOUBLE yhat1 = (pair->weights1[1].d) * invd1mag;
    DOUBLE zhat1 = (pair->weights1[2].d) * invd1mag;

    DOUBLE cij = ((DOUBLE) 0.5)*((xhat0 + xhat1)*(deltax) + (yhat0 + yhat1)*(deltay) + (zhat0 + zhat1)*(deltaz))*invdmag;
    return deltav * cij;
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline DOUBLE pairwise_vel_los_asymm_DOUBLE(const pair_struct_DOUBLE *pair){

    DOUBLE d2 = (pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d);
    DOUBLE invdmag = ((DOUBLE) 1.)/SQRT(d2);
    DOUBLE invd0mag = ((DOUBLE) 1.)/SQRT((pair->weights0[0].d)*(pair->weights0[0].d) + (pair->weights0[1].d)*(pair->weights0[1].d) + (pair->weights0[2].d)*(pair->weights0[2].d));
    DOUBLE invd1mag = ((DOUBLE) 1.)/SQRT((pair->weights1[0].d)*(pair->weights1[0].d) + (pair->weights1[1].d)*(pair->weights1[1].d) + (pair->weights1[2].d)*(pair->weights1[2].d));

    DOUBLE zero = (DOUBLE) 0.;
    if (d2 < (DOUBLE) 1.e-10) {
      invdmag = zero;
    }
    
    DOUBLE deltax = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltay = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltaz = pair->weights0[2].d - pair->weights1[2].d;
    //DOUBLE deltav = pair->weights0[3].d - pair->weights1[3].d;
    
    DOUBLE xhat0 = (pair->weights0[0].d) * invd0mag;
    DOUBLE yhat0 = (pair->weights0[1].d) * invd0mag;
    DOUBLE zhat0 = (pair->weights0[2].d) * invd0mag;

    DOUBLE xhat1 = (pair->weights1[0].d) * invd1mag;
    DOUBLE yhat1 = (pair->weights1[1].d) * invd1mag;
    DOUBLE zhat1 = (pair->weights1[2].d) * invd1mag;
    
    DOUBLE cij = ((DOUBLE) 0.5)*((xhat0 + xhat1)*(deltax) + (yhat0 + yhat1)*(deltay) + (zhat0 + zhat1)*(deltaz))*invdmag;
    return pair->weights0[3].d * cij * pair->weights1[3].d;
}


/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline DOUBLE pairwise_vel_los_norm_DOUBLE(const pair_struct_DOUBLE *pair){
    
    DOUBLE d2 = (pair->dx.d)*(pair->dx.d) + (pair->dy.d)*(pair->dy.d) + (pair->dz.d)*(pair->dz.d);
    DOUBLE invdmag = ((DOUBLE) 1.)/SQRT(d2);
    DOUBLE invd0mag = ((DOUBLE) 1.)/SQRT((pair->weights0[0].d)*(pair->weights0[0].d) + (pair->weights0[1].d)*(pair->weights0[1].d) + (pair->weights0[2].d)*(pair->weights0[2].d));
    DOUBLE invd1mag = ((DOUBLE) 1.)/SQRT((pair->weights1[0].d)*(pair->weights1[0].d) + (pair->weights1[1].d)*(pair->weights1[1].d) + (pair->weights1[2].d)*(pair->weights1[2].d));

    DOUBLE zero = (DOUBLE) 0.;
    if (d2 < (DOUBLE) 1.e-10) {
        invdmag = zero;
    }
    
    DOUBLE deltax = pair->weights0[0].d - pair->weights1[0].d;
    DOUBLE deltay = pair->weights0[1].d - pair->weights1[1].d;
    DOUBLE deltaz = pair->weights0[2].d - pair->weights1[2].d;
    
    DOUBLE xhat0 = (pair->weights0[0].d) * invd0mag;
    DOUBLE yhat0 = (pair->weights0[1].d) * invd0mag;
    DOUBLE zhat0 = (pair->weights0[2].d) * invd0mag;

    DOUBLE xhat1 = (pair->weights1[0].d) * invd1mag;
    DOUBLE yhat1 = (pair->weights1[1].d) * invd1mag;
    DOUBLE zhat1 = (pair->weights1[2].d) * invd1mag;
    
    DOUBLE cij = ((DOUBLE) 0.5)*((xhat0 + xhat1)*(deltax) + (yhat0 + yhat1)*(deltay) + (zhat0 + zhat1)*(deltaz))*invdmag;
    return cij*cij;
}

/*
 * Weight the pair by the signed difference in radial velocity, ( v dot rhat )
 */
static inline AVX_FLOATS avx_pairwise_vel_DOUBLE(const pair_struct_DOUBLE *pair){
    AVX_FLOATS deltavx = pair->weights1[0].a - pair->weights0[0].a;
    AVX_FLOATS deltavy = pair->weights1[1].a - pair->weights0[1].a;
    AVX_FLOATS deltavz = pair->weights1[2].a - pair->weights0[2].a;
    
    AVX_FLOATS invrmag = AVX_RSQRT_FLOAT((pair->dx.a)*(pair->dx.a) + (pair->dy.a)*(pair->dy.a) + (pair->dz.a)*(pair->dz.a));
    
    return (deltavx*pair->dx.a + deltavy*pair->dy.a + deltavz*pair->dz.a)*invrmag;
}

/*
 * * Weight the pair by the squared difference in radial velocity, ( v dot rhat )^2
 */
static inline AVX_FLOATS avx_pairwise_vel2_DOUBLE(const pair_struct_DOUBLE *pair){
    AVX_FLOATS deltavx = pair->weights0[0].a - pair->weights1[0].a;
    AVX_FLOATS deltavy = pair->weights0[1].a - pair->weights1[1].a;
    AVX_FLOATS deltavz = pair->weights0[2].a - pair->weights1[2].a;
    
    AVX_FLOATS v_dot_r = deltavx*pair->dx.a + deltavy*pair->dy.a + deltavz*pair->dz.a;
    AVX_FLOATS invr2 = AVX_RECIPROCAL_FLOATS((pair->dx.a)*(pair->dx.a) + (pair->dy.a)*(pair->dy.a) + (pair->dz.a)*(pair->dz.a));
    
    return v_dot_r*v_dot_r*invr2;
}

/*
 * * Weight the pair by the cubed difference in radial velocity, ( v dot rhat )^3
 */
static inline AVX_FLOATS avx_pairwise_vel3_DOUBLE(const pair_struct_DOUBLE *pair){
    AVX_FLOATS deltavx = pair->weights1[0].a - pair->weights0[0].a;
    AVX_FLOATS deltavy = pair->weights1[1].a - pair->weights0[1].a;
    AVX_FLOATS deltavz = pair->weights1[2].a - pair->weights0[2].a;
    
    AVX_FLOATS v_dot_r = deltavx*pair->dx.a + deltavy*pair->dy.a + deltavz*pair->dz.a;
    AVX_FLOATS invr = AVX_RSQRT_FLOAT((pair->dx.a)*(pair->dx.a) + (pair->dy.a)*(pair->dy.a) + (pair->dz.a)*(pair->dz.a));
    AVX_FLOATS v_dot_rhat = v_dot_r*invr;
    return v_dot_rhat*v_dot_rhat*v_dot_rhat;
}

/*
 * * Weight the pair by the 4th power of the difference in radial velocity, ( v dot rhat )^4
 */
static inline AVX_FLOATS avx_pairwise_vel4_DOUBLE(const pair_struct_DOUBLE *pair){
    AVX_FLOATS deltavx = pair->weights0[0].a - pair->weights1[0].a;
    AVX_FLOATS deltavy = pair->weights0[1].a - pair->weights1[1].a;
    AVX_FLOATS deltavz = pair->weights0[2].a - pair->weights1[2].a;
    
    AVX_FLOATS v_dot_r = deltavx*pair->dx.a + deltavy*pair->dy.a + deltavz*pair->dz.a;
    AVX_FLOATS invr2 = AVX_RECIPROCAL_FLOATS((pair->dx.a)*(pair->dx.a) + (pair->dy.a)*(pair->dy.a) + (pair->dz.a)*(pair->dz.a));
    AVX_FLOATS v_dot_rhat_2 = v_dot_r*v_dot_r*invr2;
    
    return v_dot_rhat_2*v_dot_rhat_2;
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX_FLOATS avx_pairwise_tang_vel2_DOUBLE(const pair_struct_DOUBLE *pair){
    AVX_FLOATS deltavx = pair->weights0[0].a - pair->weights1[0].a;
    AVX_FLOATS deltavy = pair->weights0[1].a - pair->weights1[1].a;
    AVX_FLOATS deltavz = pair->weights0[2].a - pair->weights1[2].a;
    
    AVX_FLOATS v_dot_r = deltavx*pair->dx.a + deltavy*pair->dy.a + deltavz*pair->dz.a;
    AVX_FLOATS invr2 = AVX_RECIPROCAL_FLOATS((pair->dx.a)*(pair->dx.a) + (pair->dy.a)*(pair->dy.a) + (pair->dz.a)*(pair->dz.a));
    
    AVX_FLOATS deltavx_T = deltavx - v_dot_r*pair->dx.a*invr2;
    AVX_FLOATS deltavy_T = deltavy - v_dot_r*pair->dy.a*invr2;
    AVX_FLOATS deltavz_T = deltavz - v_dot_r*pair->dz.a*invr2;
    
    return deltavx_T*deltavx_T + deltavy_T*deltavy_T + deltavz_T*deltavz_T;
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX_FLOATS avx_pairwise_vel_los_DOUBLE(const pair_struct_DOUBLE *pair){

    AVX_FLOATS d2 = AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->dx.a, pair->dx.a), AVX_MULTIPLY_FLOATS(pair->dy.a, pair->dy.a)), AVX_MULTIPLY_FLOATS(pair->dz.a, pair->dz.a));
    AVX_FLOATS invdmag = AVX_RSQRT_FLOAT(d2);
    AVX_FLOATS invd0mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights0[0].a, pair->weights0[0].a), AVX_MULTIPLY_FLOATS(pair->weights0[1].a, pair->weights0[1].a)), AVX_MULTIPLY_FLOATS(pair->weights0[2].a, pair->weights0[2].a)));
    AVX_FLOATS invd1mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights1[0].a, pair->weights1[0].a), AVX_MULTIPLY_FLOATS(pair->weights1[1].a, pair->weights1[1].a)), AVX_MULTIPLY_FLOATS(pair->weights1[2].a, pair->weights1[2].a)));

    AVX_FLOATS zero = AVX_SETZERO_FLOAT();
    AVX_FLOATS mask_d2_zero = AVX_COMPARE_FLOATS(zero, d2, _CMP_LT_OS); 
    // if 0 < d2, mask is true; blend(F, T, m)
    invdmag = AVX_BLEND_FLOATS_WITH_MASK(zero, invdmag, mask_d2_zero);
    
    AVX_FLOATS deltax = AVX_SUBTRACT_FLOATS(pair->weights0[0].a, pair->weights1[0].a);
    AVX_FLOATS deltay = AVX_SUBTRACT_FLOATS(pair->weights0[1].a, pair->weights1[1].a);
    AVX_FLOATS deltaz = AVX_SUBTRACT_FLOATS(pair->weights0[2].a, pair->weights1[2].a);
    AVX_FLOATS deltav = AVX_SUBTRACT_FLOATS(pair->weights0[3].a, pair->weights1[3].a);
    
    AVX_FLOATS xhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[0].a, invd0mag);
    AVX_FLOATS yhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[1].a, invd0mag);
    AVX_FLOATS zhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[2].a, invd0mag);

    AVX_FLOATS xhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[0].a, invd1mag);
    AVX_FLOATS yhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[1].a, invd1mag);
    AVX_FLOATS zhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[2].a, invd1mag);
    
    AVX_FLOATS cij = AVX_SET_FLOAT((DOUBLE) 0.5) * invdmag * ((xhat0 + xhat1) * deltax + (yhat0 + yhat1) * deltay + (zhat0 + zhat1) * deltaz);    
    return AVX_MULTIPLY_FLOATS(cij, deltav);
}


/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX_FLOATS avx_pairwise_vel_los_asymm_DOUBLE(const pair_struct_DOUBLE *pair){

    AVX_FLOATS d2 = AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->dx.a, pair->dx.a), AVX_MULTIPLY_FLOATS(pair->dy.a, pair->dy.a)), AVX_MULTIPLY_FLOATS(pair->dz.a, pair->dz.a));
    AVX_FLOATS invdmag = AVX_RSQRT_FLOAT(d2);
    AVX_FLOATS invd0mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights0[0].a, pair->weights0[0].a), AVX_MULTIPLY_FLOATS(pair->weights0[1].a, pair->weights0[1].a)), AVX_MULTIPLY_FLOATS(pair->weights0[2].a, pair->weights0[2].a)));
    AVX_FLOATS invd1mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights1[0].a, pair->weights1[0].a), AVX_MULTIPLY_FLOATS(pair->weights1[1].a, pair->weights1[1].a)), AVX_MULTIPLY_FLOATS(pair->weights1[2].a, pair->weights1[2].a)));

    AVX_FLOATS zero = AVX_SETZERO_FLOAT();
    AVX_FLOATS mask_d2_zero = AVX_COMPARE_FLOATS(zero, d2, _CMP_LT_OS); 
    // if 0 < d2, mask is true; blend(F, T, m)
    invdmag = AVX_BLEND_FLOATS_WITH_MASK(zero, invdmag, mask_d2_zero);
    
    AVX_FLOATS deltax = AVX_SUBTRACT_FLOATS(pair->weights0[0].a, pair->weights1[0].a);
    AVX_FLOATS deltay = AVX_SUBTRACT_FLOATS(pair->weights0[1].a, pair->weights1[1].a);
    AVX_FLOATS deltaz = AVX_SUBTRACT_FLOATS(pair->weights0[2].a, pair->weights1[2].a);
    //AVX_FLOATS deltav = AVX_SUBTRACT_FLOATS(pair->weights0[3].a, pair->weights1[3].a);
    
    AVX_FLOATS xhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[0].a, invd0mag);
    AVX_FLOATS yhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[1].a, invd0mag);
    AVX_FLOATS zhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[2].a, invd0mag);

    AVX_FLOATS xhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[0].a, invd1mag);
    AVX_FLOATS yhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[1].a, invd1mag);
    AVX_FLOATS zhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[2].a, invd1mag);

    AVX_FLOATS cij = AVX_SET_FLOAT((DOUBLE) 0.5) * invdmag * ((xhat0 + xhat1) * deltax + (yhat0 + yhat1) * deltay + (zhat0 + zhat1) * deltaz);
    return AVX_MULTIPLY_FLOATS(AVX_MULTIPLY_FLOATS(cij, pair->weights0[3].a), pair->weights1[3].a);
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX_FLOATS avx_pairwise_vel_los_norm_DOUBLE(const pair_struct_DOUBLE *pair){

    AVX_FLOATS d2 = AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->dx.a, pair->dx.a), AVX_MULTIPLY_FLOATS(pair->dy.a, pair->dy.a)), AVX_MULTIPLY_FLOATS(pair->dz.a, pair->dz.a));
    AVX_FLOATS invdmag = AVX_RSQRT_FLOAT(d2);
    AVX_FLOATS invd0mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights0[0].a, pair->weights0[0].a), AVX_MULTIPLY_FLOATS(pair->weights0[1].a, pair->weights0[1].a)), AVX_MULTIPLY_FLOATS(pair->weights0[2].a, pair->weights0[2].a)));
    AVX_FLOATS invd1mag = AVX_RSQRT_FLOAT(AVX_ADD_FLOATS(AVX_ADD_FLOATS(AVX_MULTIPLY_FLOATS(pair->weights1[0].a, pair->weights1[0].a), AVX_MULTIPLY_FLOATS(pair->weights1[1].a, pair->weights1[1].a)), AVX_MULTIPLY_FLOATS(pair->weights1[2].a, pair->weights1[2].a)));

    AVX_FLOATS zero = AVX_SETZERO_FLOAT();
    AVX_FLOATS mask_d2_zero = AVX_COMPARE_FLOATS(zero, d2, _CMP_LT_OS); 
    // if 0 < d2, mask is true; blend(F, T, m)
    invdmag = AVX_BLEND_FLOATS_WITH_MASK(zero, invdmag, mask_d2_zero);
    
    AVX_FLOATS deltax = AVX_SUBTRACT_FLOATS(pair->weights0[0].a, pair->weights1[0].a);
    AVX_FLOATS deltay = AVX_SUBTRACT_FLOATS(pair->weights0[1].a, pair->weights1[1].a);
    AVX_FLOATS deltaz = AVX_SUBTRACT_FLOATS(pair->weights0[2].a, pair->weights1[2].a);
    
    AVX_FLOATS xhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[0].a, invd0mag);
    AVX_FLOATS yhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[1].a, invd0mag);
    AVX_FLOATS zhat0 = AVX_MULTIPLY_FLOATS(pair->weights0[2].a, invd0mag);

    AVX_FLOATS xhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[0].a, invd1mag);
    AVX_FLOATS yhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[1].a, invd1mag);
    AVX_FLOATS zhat1 = AVX_MULTIPLY_FLOATS(pair->weights1[2].a, invd1mag);

    AVX_FLOATS cij = AVX_SET_FLOAT((DOUBLE) 0.5) * invdmag * ((xhat0 + xhat1) * deltax + (yhat0 + yhat1) * deltay + (zhat0 + zhat1) * deltaz);
    return AVX_MULTIPLY_FLOATS(cij, cij);
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX512_FLOATS avx512_pairwise_vel_los_DOUBLE(const pair_struct_DOUBLE *pair){
  
    AVX512_FLOATS d2 = AVX512_FMA_ADD_FLOATS(pair->dx.a512, pair->dx.a512, AVX512_FMA_ADD_FLOATS(pair->dy.a512, pair->dy.a512, AVX512_MULTIPLY_FLOATS(pair->dz.a512, pair->dz.a512)));
    //AVX512_FLOATS invdmag = AVX512_RECIPROCAL_FLOATS(AVX512_SQRT_FLOAT(d2));
    AVX512_FLOATS invdmag = AVX512_RSQRT_FLOAT(d2);
    AVX512_FLOATS invd0mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights0[0].a512, pair->weights0[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights0[1].a512, pair->weights0[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, pair->weights0[2].a512))));
    AVX512_FLOATS invd1mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights1[0].a512, pair->weights1[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights1[1].a512, pair->weights1[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, pair->weights1[2].a512))));
  
    AVX512_FLOATS zero = AVX512_SETZERO_FLOAT();
    AVX512_MASK mask_d2_zero = AVX512_COMPARE_FLOATS(zero, d2, _CMP_LT_OQ); 
    // if 0 < d2, mask is true; blend(m, F, T)
    invdmag = AVX512_BLEND_FLOATS_WITH_MASK(mask_d2_zero, zero, invdmag);
    
    AVX512_FLOATS deltax = AVX512_SUBTRACT_FLOATS(pair->weights0[0].a512, pair->weights1[0].a512);
    AVX512_FLOATS deltay = AVX512_SUBTRACT_FLOATS(pair->weights0[1].a512, pair->weights1[1].a512);
    AVX512_FLOATS deltaz = AVX512_SUBTRACT_FLOATS(pair->weights0[2].a512, pair->weights1[2].a512);
    AVX512_FLOATS deltav = AVX512_SUBTRACT_FLOATS(pair->weights0[3].a512, pair->weights1[3].a512);
    
    AVX512_FLOATS xhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[0].a512, invd0mag);
    AVX512_FLOATS yhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[1].a512, invd0mag);
    AVX512_FLOATS zhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, invd0mag);

    AVX512_FLOATS xhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[0].a512, invd1mag);
    AVX512_FLOATS yhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[1].a512, invd1mag);
    AVX512_FLOATS zhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, invd1mag);
    
    AVX512_FLOATS cij = AVX512_MULTIPLY_FLOATS(AVX512_SET_FLOAT((DOUBLE) 0.5), AVX512_MULTIPLY_FLOATS(AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(xhat0, xhat1), deltax, AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(yhat0, yhat1), deltay, AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(zhat0, zhat1), deltaz))), invdmag));
    //AVX512_FLOATS cij = AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(AVX512_ADD_FLOATS(AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(xhat0, xhat1), deltax), AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(yhat0, yhat1),deltay)), AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(zhat0, zhat1), deltaz)), invdmag); // old version (need to also change invd's)
    return AVX512_MULTIPLY_FLOATS(cij, deltav);
}


/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX512_FLOATS avx512_pairwise_vel_los_asymm_DOUBLE(const pair_struct_DOUBLE *pair){

    AVX512_FLOATS d2 = AVX512_FMA_ADD_FLOATS(pair->dx.a512, pair->dx.a512, AVX512_FMA_ADD_FLOATS(pair->dy.a512, pair->dy.a512, AVX512_MULTIPLY_FLOATS(pair->dz.a512, pair->dz.a512)));
    AVX512_FLOATS invdmag = AVX512_RSQRT_FLOAT(d2);
    AVX512_FLOATS invd0mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights0[0].a512, pair->weights0[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights0[1].a512, pair->weights0[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, pair->weights0[2].a512))));
    AVX512_FLOATS invd1mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights1[0].a512, pair->weights1[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights1[1].a512, pair->weights1[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, pair->weights1[2].a512))));

    AVX512_FLOATS zero = AVX512_SETZERO_FLOAT();
    AVX512_MASK mask_d2_zero = AVX512_COMPARE_FLOATS(zero, d2, _CMP_LT_OQ); 
    // if 0 < d2, mask is true; blend(m, F, T)
    invdmag = AVX512_BLEND_FLOATS_WITH_MASK(mask_d2_zero, zero, invdmag);
    
    AVX512_FLOATS deltax = AVX512_SUBTRACT_FLOATS(pair->weights0[0].a512, pair->weights1[0].a512);
    AVX512_FLOATS deltay = AVX512_SUBTRACT_FLOATS(pair->weights0[1].a512, pair->weights1[1].a512);
    AVX512_FLOATS deltaz = AVX512_SUBTRACT_FLOATS(pair->weights0[2].a512, pair->weights1[2].a512);
    //AVX512_FLOATS deltav = AVX512_SUBTRACT_FLOATS(pair->weights0[3].a512, pair->weights1[3].a512);
    
    AVX512_FLOATS xhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[0].a512, invd0mag);
    AVX512_FLOATS yhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[1].a512, invd0mag);
    AVX512_FLOATS zhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, invd0mag);

    AVX512_FLOATS xhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[0].a512, invd1mag);
    AVX512_FLOATS yhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[1].a512, invd1mag);
    AVX512_FLOATS zhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, invd1mag);
    
    // c_ij = 0.5 (hat x_i + hat x_j) dot hat x_ij, but we multiply this by two because the numerator is multiplied by two // AVX512_SET_FLOAT((DOUBLE) 0.5)
    AVX512_FLOATS cij = AVX512_MULTIPLY_FLOATS(AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(xhat0, xhat1), deltax, AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(yhat0, yhat1), deltay, AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(zhat0, zhat1), deltaz))), invdmag);
    return AVX512_MULTIPLY_FLOATS(AVX512_MULTIPLY_FLOATS(cij, pair->weights0[3].a512), pair->weights1[3].a512);
}

/*
 * Weight the pair by the squared difference in tangential velocity, | v - (v dot rhat)*rhat |^2
 */
static inline AVX512_FLOATS avx512_pairwise_vel_los_norm_DOUBLE(const pair_struct_DOUBLE *pair){

    AVX512_FLOATS d2 = AVX512_FMA_ADD_FLOATS(pair->dx.a512, pair->dx.a512, AVX512_FMA_ADD_FLOATS(pair->dy.a512, pair->dy.a512, AVX512_MULTIPLY_FLOATS(pair->dz.a512, pair->dz.a512)));
    AVX512_FLOATS invdmag = AVX512_RSQRT_FLOAT(d2);
    AVX512_FLOATS invd0mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights0[0].a512, pair->weights0[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights0[1].a512, pair->weights0[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, pair->weights0[2].a512))));
    AVX512_FLOATS invd1mag = AVX512_RSQRT_FLOAT(AVX512_FMA_ADD_FLOATS(pair->weights1[0].a512, pair->weights1[0].a512, AVX512_FMA_ADD_FLOATS(pair->weights1[1].a512, pair->weights1[1].a512, AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, pair->weights1[2].a512))));

    AVX512_FLOATS zero = AVX512_SETZERO_FLOAT();
    AVX512_MASK mask_d2_zero = AVX512_COMPARE_FLOATS(zero, d2, _CMP_LT_OQ); 
    // if 0 < d2, mask is true; blend(m, F, T)
    invdmag = AVX512_BLEND_FLOATS_WITH_MASK(mask_d2_zero, zero, invdmag);
    
    AVX512_FLOATS deltax = AVX512_SUBTRACT_FLOATS(pair->weights0[0].a512, pair->weights1[0].a512);
    AVX512_FLOATS deltay = AVX512_SUBTRACT_FLOATS(pair->weights0[1].a512, pair->weights1[1].a512);
    AVX512_FLOATS deltaz = AVX512_SUBTRACT_FLOATS(pair->weights0[2].a512, pair->weights1[2].a512);
    
    AVX512_FLOATS xhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[0].a512, invd0mag);
    AVX512_FLOATS yhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[1].a512, invd0mag);
    AVX512_FLOATS zhat0 = AVX512_MULTIPLY_FLOATS(pair->weights0[2].a512, invd0mag);

    AVX512_FLOATS xhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[0].a512, invd1mag);
    AVX512_FLOATS yhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[1].a512, invd1mag);
    AVX512_FLOATS zhat1 = AVX512_MULTIPLY_FLOATS(pair->weights1[2].a512, invd1mag);
    
    AVX512_FLOATS cij = AVX512_MULTIPLY_FLOATS(AVX512_SET_FLOAT((DOUBLE) 0.5), AVX512_MULTIPLY_FLOATS(AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(xhat0, xhat1), deltax, AVX512_FMA_ADD_FLOATS(AVX512_ADD_FLOATS(yhat0, yhat1), deltay, AVX512_MULTIPLY_FLOATS(AVX512_ADD_FLOATS(zhat0, zhat1), deltaz))), invdmag));
    return AVX512_MULTIPLY_FLOATS(cij, cij);
}

    

//////////////////////////////////
// Utility functions
//////////////////////////////////


/* Gives a pointer to the weight function for the given weighting method
 * and instruction set.
 */
static inline weight_func_t_DOUBLE get_weight_func_by_method_DOUBLE(const weight_method_t method){
    switch(method){
        case PAIR_PRODUCT:
            return &pair_product_DOUBLE;
        case PAIRWISE_VEL:
            return &pairwise_vel_DOUBLE;
        case PAIRWISE_VEL2:
            return &pairwise_vel2_DOUBLE;
        case PAIRWISE_VEL3:
            return &pairwise_vel3_DOUBLE;
        case PAIRWISE_VEL4:
            return &pairwise_vel4_DOUBLE;
        case PAIRWISE_TANG_VEL2:
            return &pairwise_tang_vel2_DOUBLE;
        case PAIRWISE_VEL_LOS:
            return &pairwise_vel_los_DOUBLE;
        case PAIRWISE_VEL_LOS_ASYMM:
            return &pairwise_vel_los_asymm_DOUBLE;
        case PAIRWISE_VEL_LOS_NORM:
            return &pairwise_vel_los_norm_DOUBLE;
        default:
        case NONE:
            return NULL;
    }
}

#ifdef __AVX512F__
static inline avx512_weight_func_t_DOUBLE get_avx512_weight_func_by_method_DOUBLE(const weight_method_t method){
    switch(method){
        case PAIR_PRODUCT:
            return &avx512_pair_product_DOUBLE;
        case PAIRWISE_VEL_LOS:
            return &avx512_pairwise_vel_los_DOUBLE;
        case PAIRWISE_VEL_LOS_ASYMM:
            return &avx512_pairwise_vel_los_asymm_DOUBLE;
        case PAIRWISE_VEL_LOS_NORM:
            return &avx512_pairwise_vel_los_norm_DOUBLE;
        default:
        case NONE:
            return NULL;
    }
}
#endif


#ifdef __AVX__
static inline avx_weight_func_t_DOUBLE get_avx_weight_func_by_method_DOUBLE(const weight_method_t method){
    switch(method){
        case PAIR_PRODUCT:
            return &avx_pair_product_DOUBLE;
        case PAIRWISE_VEL:
            return &avx_pairwise_vel_DOUBLE;
        case PAIRWISE_VEL2:
            return &avx_pairwise_vel2_DOUBLE;
        case PAIRWISE_VEL3:
            return &avx_pairwise_vel3_DOUBLE;
        case PAIRWISE_VEL4:
            return &avx_pairwise_vel4_DOUBLE;
        case PAIRWISE_TANG_VEL2:
            return &avx_pairwise_tang_vel2_DOUBLE;
        case PAIRWISE_VEL_LOS:
            return &avx_pairwise_vel_los_DOUBLE;
        case PAIRWISE_VEL_LOS_ASYMM:
            return &avx_pairwise_vel_los_asymm_DOUBLE;
        case PAIRWISE_VEL_LOS_NORM:
            return &avx_pairwise_vel_los_norm_DOUBLE;
        default:
        case NONE:
            return NULL;
    }
}
#endif

#ifdef __SSE4_2__
static inline sse_weight_func_t_DOUBLE get_sse_weight_func_by_method_DOUBLE(const weight_method_t method){
    switch(method){
        case PAIR_PRODUCT:
            return &sse_pair_product_DOUBLE;
        default:
        case NONE:
            return NULL;
    }
}
#endif
